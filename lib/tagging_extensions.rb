class ActiveRecord::Base #:nodoc:

  module TaggingFinders
    #
    # Find all the objects tagged with the supplied list of tags
    #
    # Usage : Model.tagged_with("ruby")
    #         Model.tagged_with("hello", "world")
    #         Model.tagged_with("hello", "world", :limit => 10)
    #
    def tagged_with(*tag_list)
      options = tag_list.last.is_a?(Hash) ? tag_list.pop : {}
      # tag_list = (tag_list)

      scope = scope(:find)
      options[:select] ||= "#{table_name}.*"
      options[:from] ||= "#{table_name}, tags, taggings"

      sql  = "SELECT #{(scope && scope[:select]) || options[:select]} "
      sql << "FROM #{(scope && scope[:from]) || options[:from]} "

      add_joins!(sql, options[:joins], scope)

      sql << "WHERE #{table_name}.#{primary_key} = taggings.taggable_id "
      sql << "AND taggings.taggable_type = '#{ActiveRecord::Base.send(:class_name_of_active_record_descendant, self).to_s}' "
      sql << "AND taggings.tag_id = tags.id "

      tag_list_condition = tag_list.map {|t| "'#{t}'"}.join(", ")

      sql << "AND (tags.name IN (#{sanitize_sql(tag_list_condition)})) "
      sql << "AND #{sanitize_sql(options[:conditions])} " if options[:conditions]
      sql << "GROUP BY #{table_name}.id "
      sql << "HAVING COUNT(taggings.tag_id) = #{tag_list.size}"

      add_order!(sql, options[:order], scope)
      add_limit!(sql, options, scope)
      add_lock!(sql, options, scope)

      find_by_sql(sql)
    end

    def parse_tags(tag_string)
      return [] if tag_string.blank?
      tag_string.split(Tag::PARSE_EXPRESSION_SPLITTER).reject(&:blank?).map { |tag_name| tag_name.strip.squeeze(" ") }.flatten.compact.uniq
    end

    # Options:
    #  :conditions - A piece of SQL conditions to add to the query
    #  :limit - The maximum number of tags to return
    #  :order - A piece of SQL to order by. Eg 'tags.count desc' or 'taggings.created_at desc'
    #  :at_least - Exclude tags with a frequency less than the given value
    #  :at_most - Exclude tags with a frequency greater then the given value
    def tag_counts(options = {})
      options.assert_valid_keys :conditions, :at_least, :at_most, :order, :limit

      # Conditions umwandeln in String, weil wir nachher noch mehr SQL anhängen
      if options[:conditions]
        options[:conditions] = sanitize_sql_for_conditions(options[:conditions])
      end

      # taggable_type schränkt auf Tags eines bestimmten Model-Typs ein. 
      conditions = '(' + [options[:conditions], "taggings.taggable_type = '#{self.to_s}'"].compact.join(') AND (') + ')'
      
      at_least  = sanitize_sql(['count >= ?', options[:at_least]]) if options[:at_least]
      at_most   = sanitize_sql(['count <= ?', options[:at_most]]) if options[:at_most]
      having    = [at_least, at_most].compact.join(' and ')
      group_by  = 'tags.id, tags.name having count(*) > 0'
      group_by << " and #{having}" unless having.blank?
      order     = options[:order] || 'count DESC'

      Tag.find(:all,
        :select     => 'tags.id, tags.name, COUNT(*) AS count', 
        :joins      => "LEFT OUTER JOIN taggings ON tags.id = taggings.tag_id",
        :conditions => conditions,
        :group      => group_by,
        :order      => order,
        :limit      => options[:limit]
      )
    end


  end

  # These extensions make models taggable. This file is automatically generated and required by your app if you run the tagging generator included with has_many_polymorphs.
  module TaggingExtensions

    # Add tags to <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    #
    # We need to avoid name conflicts with the built-in ActiveRecord association methods, thus the underscores.
    def _add_tags incoming
      taggable?(true)
      tag_cast_to_string(incoming).each do |tag_name|
        begin
          tag = Tag.find_or_create_by_name(tag_name)
          raise Tag::Error, "tag could not be saved: #{tag_name}" if tag.new_record?
          tag.taggables << self
        rescue ActiveRecord::StatementInvalid => e
          raise unless e.to_s =~ /duplicate/i
        end
      end
    end

    # Removes tags from <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    def _remove_tags outgoing
      taggable?(true)
      outgoing = tag_cast_to_string(outgoing)

      tags.delete(*(tags.select do |tag|
        outgoing.include? tag.name
      end))
    end

    # Replace the existing tags on <tt>self</tt>. Accepts a string of tagnames, an array of tagnames, an array of ids, or an array of Tags.
    def tag_with list
      #:stopdoc:
      taggable?(true)
      list = tag_cast_to_string(list)

      # Transactions may not be ideal for you here; be aware.
      Tag.transaction do
        current = tags.map(&:name)
        _add_tags(list - current)
        _remove_tags(current - list)
      end

      self
      #:startdoc:
    end

   # Returns the tags on <tt>self</tt> as a string.
    def tag_list #:nodoc:
      #:stopdoc:
      taggable?(true)
      tags.reload
      tags.to_s
      #:startdoc:
    end

    private ###################################################################

    def tag_cast_to_string obj #:nodoc:
      case obj
        when Array
          obj.map! do |item|
            case item
              when /^\d+$/, Fixnum then Tag.find(item).name # This will be slow if you use ids a lot.
              when Tag then item.name
              when String then item
              else
                raise "Invalid type"
            end
          end
        when String
          obj = ActiveRecord::Base.parse_tags(obj)
        else
          raise "Invalid object of class #{obj.class} as tagging method parameter"
      end.flatten.compact.uniq
    end

    # Check if a model is in the :taggables target list. The alternative to this check is to explicitly include a TaggingMethods module (which you would create) in each target model.
    def taggable?(should_raise = false) #:nodoc:
      unless flag = respond_to?(:tags)
        raise "#{self.class} is not a taggable model" if should_raise
      end
      flag
    end

  end

  extend  TaggingFinders
  include TaggingExtensions
end
